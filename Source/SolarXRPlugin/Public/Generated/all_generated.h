// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "data_feed_generated.h"
#include "pub_sub_generated.h"
#include "rpc_generated.h"

namespace solarxr_protocol {

struct MessageBundle;
struct MessageBundleBuilder;
struct MessageBundleT;

struct MessageBundleT : public ::flatbuffers::NativeTable {
  typedef MessageBundle TableType;
  std::vector<std::unique_ptr<solarxr_protocol::data_feed::DataFeedMessageHeaderT>> data_feed_msgs{};
  std::vector<std::unique_ptr<solarxr_protocol::rpc::RpcMessageHeaderT>> rpc_msgs{};
  std::vector<std::unique_ptr<solarxr_protocol::pub_sub::PubSubHeaderT>> pub_sub_msgs{};
  MessageBundleT() = default;
  MessageBundleT(const MessageBundleT &o);
  MessageBundleT(MessageBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  MessageBundleT &operator=(MessageBundleT o) FLATBUFFERS_NOEXCEPT;
};

/// MessageBundle contains all of the messages for the data feed system and the
/// rpc system that will be sent in one buffer.
struct MessageBundle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBundleT NativeTableType;
  typedef MessageBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_FEED_MSGS = 4,
    VT_RPC_MSGS = 6,
    VT_PUB_SUB_MSGS = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *data_feed_msgs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *>(VT_DATA_FEED_MSGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *rpc_msgs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *>(VT_RPC_MSGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>> *pub_sub_msgs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>> *>(VT_PUB_SUB_MSGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_FEED_MSGS) &&
           verifier.VerifyVector(data_feed_msgs()) &&
           verifier.VerifyVectorOfTables(data_feed_msgs()) &&
           VerifyOffset(verifier, VT_RPC_MSGS) &&
           verifier.VerifyVector(rpc_msgs()) &&
           verifier.VerifyVectorOfTables(rpc_msgs()) &&
           VerifyOffset(verifier, VT_PUB_SUB_MSGS) &&
           verifier.VerifyVector(pub_sub_msgs()) &&
           verifier.VerifyVectorOfTables(pub_sub_msgs()) &&
           verifier.EndTable();
  }
  MessageBundleT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageBundleT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MessageBundle> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MessageBundleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MessageBundleBuilder {
  typedef MessageBundle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_feed_msgs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>> data_feed_msgs) {
    fbb_.AddOffset(MessageBundle::VT_DATA_FEED_MSGS, data_feed_msgs);
  }
  void add_rpc_msgs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>> rpc_msgs) {
    fbb_.AddOffset(MessageBundle::VT_RPC_MSGS, rpc_msgs);
  }
  void add_pub_sub_msgs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>>> pub_sub_msgs) {
    fbb_.AddOffset(MessageBundle::VT_PUB_SUB_MSGS, pub_sub_msgs);
  }
  explicit MessageBundleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageBundle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageBundle> CreateMessageBundle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>> data_feed_msgs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>> rpc_msgs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>>> pub_sub_msgs = 0) {
  MessageBundleBuilder builder_(_fbb);
  builder_.add_pub_sub_msgs(pub_sub_msgs);
  builder_.add_rpc_msgs(rpc_msgs);
  builder_.add_data_feed_msgs(data_feed_msgs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MessageBundle> CreateMessageBundleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *data_feed_msgs = nullptr,
    const std::vector<::flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *rpc_msgs = nullptr,
    const std::vector<::flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>> *pub_sub_msgs = nullptr) {
  auto data_feed_msgs__ = data_feed_msgs ? _fbb.CreateVector<::flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>(*data_feed_msgs) : 0;
  auto rpc_msgs__ = rpc_msgs ? _fbb.CreateVector<::flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>(*rpc_msgs) : 0;
  auto pub_sub_msgs__ = pub_sub_msgs ? _fbb.CreateVector<::flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>>(*pub_sub_msgs) : 0;
  return solarxr_protocol::CreateMessageBundle(
      _fbb,
      data_feed_msgs__,
      rpc_msgs__,
      pub_sub_msgs__);
}

::flatbuffers::Offset<MessageBundle> CreateMessageBundle(::flatbuffers::FlatBufferBuilder &_fbb, const MessageBundleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MessageBundleT::MessageBundleT(const MessageBundleT &o) {
  data_feed_msgs.reserve(o.data_feed_msgs.size());
  for (const auto &data_feed_msgs_ : o.data_feed_msgs) { data_feed_msgs.emplace_back((data_feed_msgs_) ? new solarxr_protocol::data_feed::DataFeedMessageHeaderT(*data_feed_msgs_) : nullptr); }
  rpc_msgs.reserve(o.rpc_msgs.size());
  for (const auto &rpc_msgs_ : o.rpc_msgs) { rpc_msgs.emplace_back((rpc_msgs_) ? new solarxr_protocol::rpc::RpcMessageHeaderT(*rpc_msgs_) : nullptr); }
  pub_sub_msgs.reserve(o.pub_sub_msgs.size());
  for (const auto &pub_sub_msgs_ : o.pub_sub_msgs) { pub_sub_msgs.emplace_back((pub_sub_msgs_) ? new solarxr_protocol::pub_sub::PubSubHeaderT(*pub_sub_msgs_) : nullptr); }
}

inline MessageBundleT &MessageBundleT::operator=(MessageBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(data_feed_msgs, o.data_feed_msgs);
  std::swap(rpc_msgs, o.rpc_msgs);
  std::swap(pub_sub_msgs, o.pub_sub_msgs);
  return *this;
}

inline MessageBundleT *MessageBundle::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MessageBundleT>(new MessageBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageBundle::UnPackTo(MessageBundleT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data_feed_msgs(); if (_e) { _o->data_feed_msgs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->data_feed_msgs[_i]) { _e->Get(_i)->UnPackTo(_o->data_feed_msgs[_i].get(), _resolver); } else { _o->data_feed_msgs[_i] = std::unique_ptr<solarxr_protocol::data_feed::DataFeedMessageHeaderT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->data_feed_msgs.resize(0); } }
  { auto _e = rpc_msgs(); if (_e) { _o->rpc_msgs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->rpc_msgs[_i]) { _e->Get(_i)->UnPackTo(_o->rpc_msgs[_i].get(), _resolver); } else { _o->rpc_msgs[_i] = std::unique_ptr<solarxr_protocol::rpc::RpcMessageHeaderT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->rpc_msgs.resize(0); } }
  { auto _e = pub_sub_msgs(); if (_e) { _o->pub_sub_msgs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->pub_sub_msgs[_i]) { _e->Get(_i)->UnPackTo(_o->pub_sub_msgs[_i].get(), _resolver); } else { _o->pub_sub_msgs[_i] = std::unique_ptr<solarxr_protocol::pub_sub::PubSubHeaderT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->pub_sub_msgs.resize(0); } }
}

inline ::flatbuffers::Offset<MessageBundle> MessageBundle::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MessageBundleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageBundle(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MessageBundle> CreateMessageBundle(::flatbuffers::FlatBufferBuilder &_fbb, const MessageBundleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MessageBundleT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data_feed_msgs = _o->data_feed_msgs.size() ? _fbb.CreateVector<::flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> (_o->data_feed_msgs.size(), [](size_t i, _VectorArgs *__va) { return CreateDataFeedMessageHeader(*__va->__fbb, __va->__o->data_feed_msgs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _rpc_msgs = _o->rpc_msgs.size() ? _fbb.CreateVector<::flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> (_o->rpc_msgs.size(), [](size_t i, _VectorArgs *__va) { return CreateRpcMessageHeader(*__va->__fbb, __va->__o->rpc_msgs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _pub_sub_msgs = _o->pub_sub_msgs.size() ? _fbb.CreateVector<::flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>> (_o->pub_sub_msgs.size(), [](size_t i, _VectorArgs *__va) { return CreatePubSubHeader(*__va->__fbb, __va->__o->pub_sub_msgs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return solarxr_protocol::CreateMessageBundle(
      _fbb,
      _data_feed_msgs,
      _rpc_msgs,
      _pub_sub_msgs);
}

}  // namespace solarxr_protocol

#endif  // FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_
